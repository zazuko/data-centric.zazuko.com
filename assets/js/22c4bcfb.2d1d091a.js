"use strict";(self.webpackChunkdata_centric_zazuko_com=self.webpackChunkdata_centric_zazuko_com||[]).push([[572],{7312:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=t(5893),i=t(1151);const r={},l="Fail pipeline gracefully",s={id:"workflows/how-to/fail-pipeline-gently",title:"Fail pipeline gracefully",description:"The easiest way to stop a pipeline is to throw an exception. However, this will stop the pipeline immediately.",source:"@site/docs/workflows/how-to/fail-pipeline-gently.md",sourceDirName:"workflows/how-to",slug:"/workflows/how-to/fail-pipeline-gently",permalink:"/docs/workflows/how-to/fail-pipeline-gently",draft:!1,unlisted:!1,editUrl:"https://github.com/zazuko/data-centric.zazuko.com/tree/main/docs/workflows/how-to/fail-pipeline-gently.md",tags:[],version:"current",frontMatter:{},sidebar:"workflowsSidebar",previous:{title:"Extend barnard59 CLI",permalink:"/docs/workflows/how-to/extend-banard59-cli"},next:{title:"Remove meta CSVW triples",permalink:"/docs/workflows/how-to/remove-meta-csvw-triples"}},a={},c=[{value:"<code>this.error()</code> to the rescue",id:"thiserror-to-the-rescue",level:2}];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"fail-pipeline-gracefully",children:"Fail pipeline gracefully"}),"\n",(0,o.jsx)(n.p,{children:"The easiest way to stop a pipeline is to throw an exception. However, this will stop the pipeline immediately.\nConsider the simple step implementation below."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export default function streamFailingRandomly() {\n  return async function * (source) {\n    let total = 0;\n\n    for await (const chunk of source) {\n      if (Math.random() > 0.5) {\n        throw new Error('Random error');\n      } else {\n        total += chunk.length;\n        yield chunk;\n      }\n    }\n   \n    this.logger.info(`Total processed: ${total}`);\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"When the error is thrown, the pipeline will stop immediately. No further chunks will be processed and the code following\nthe async loop will not be reached.\nThis is quite clear in generator-style implementations but can be a surprise when implementing steps using low-level streams.\nIn the latter case, the flush callback will not be called."}),"\n",(0,o.jsx)(n.p,{children:"What's more, an exception thrown in one step affects other steps in the pipeline, preventing their respective flush\ncallbacks from being called."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"try..catch"})," block will not help here. When an error is thrown inside the async generator, it will be caught by the\npipeline and the processing is stopped immediately."]})}),"\n",(0,o.jsxs)(n.h2,{id:"thiserror-to-the-rescue",children:[(0,o.jsx)(n.code,{children:"this.error()"})," to the rescue"]}),"\n",(0,o.jsxs)(n.p,{children:["The solution is to use the ",(0,o.jsx)(n.code,{children:"this.error()"})," method. It will instruct barnard that an error occurred but will not stop\nprocessing. It is the responsibility of the step implementor how to handle the rest of the stream."]}),"\n",(0,o.jsxs)(n.p,{children:["For the example above, the implementation could be changed to break the loop and call ",(0,o.jsx)(n.code,{children:"this.error"})," instead of throwing."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export default function streamFailingRandomly() {\n  return async function * (source) {\n    let total = 0;\n    \n    for await (const chunk of source) {\n      if (Math.random() > 0.5) {\n        this.error(new Error('Random error'));\n        break;\n      } else {\n        total += chunk.length;\n        yield chunk;\n      }\n    }\n\n    this.logger.info(`Total processed: ${total}`);\n  }.bind(this)\n}\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"caution",children:(0,o.jsxs)(n.p,{children:["When ",(0,o.jsx)(n.code,{children:"this.error"})," is called, even when the implementor breaks the loop, the pipeline will still continue to the end.\nAll chunks which were already processed will be passed to the subsequent steps and the pipeline itself will not break.\nThis is important for example when writing to a HTTP endpoint. Unlike when throwing an exception, the HTTP request will\nbe sent, albeit possibly incomplete."]})})]})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>l});var o=t(7294);const i={},r=o.createContext(i);function l(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);