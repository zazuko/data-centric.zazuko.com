"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[122],{7061:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var a=n(5893),t=n(1151);const s={title:"Pipeline Concepts",sidebar_position:1},r="Pipeline",l={id:"workflows/explanations/pipeline",title:"Pipeline Concepts",description:"Concept",source:"@site/docs/workflows/explanations/pipeline.md",sourceDirName:"workflows/explanations",slug:"/workflows/explanations/pipeline",permalink:"/docs/workflows/explanations/pipeline",draft:!1,unlisted:!1,editUrl:"https://github.com/zazuko/data-centric.zazuko.com/tree/main/docs/workflows/explanations/pipeline.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Pipeline Concepts",sidebar_position:1},sidebar:"workflowsSidebar",previous:{title:"Remove meta CSVW triples",permalink:"/docs/workflows/how-to/remove-meta-csvw-triples"},next:{title:"Operations",permalink:"/docs/workflows/explanations/operations"}},o={},d=[{value:"Concept",id:"concept",level:2},{value:"Internals",id:"internals",level:3},{value:"Pipeline Definition",id:"pipeline-definition",level:2},{value:"Pipeline",id:"pipeline-1",level:3},{value:"Step",id:"step",level:3},{value:"Variables",id:"variables",level:3},{value:"Definition attached to the Pipeline",id:"definition-attached-to-the-pipeline",level:4},{value:"Using Variables via Datatype",id:"using-variables-via-datatype",level:4},{value:"Using Variables in Template Literals",id:"using-variables-in-template-literals",level:4},{value:"Using Variables in ECMAScript Code",id:"using-variables-in-ecmascript-code",level:4},{value:"JavaScript Arguments",id:"javascript-arguments",level:3},{value:"EcmaScript",id:"ecmascript",level:4},{value:"EcmaScript Template Literal",id:"ecmascript-template-literal",level:4},{value:"Writing valid pipeline",id:"writing-valid-pipeline",level:2}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,t.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.h1,{id:"pipeline",children:"Pipeline"}),"\n",(0,a.jsx)(i.h2,{id:"concept",children:"Concept"}),"\n",(0,a.jsxs)(i.p,{children:["A pipeline is a way to extract, transform, and load data (ETL). barnard59 pipelines are described in RDF format.\nMore specifically, they use the ",(0,a.jsx)(i.a,{href:"https://pipeline.described.at/",children:"pipeline"})," and ",(0,a.jsx)(i.a,{href:"https://code.described.at/",children:"code"})," ontology."]}),"\n",(0,a.jsxs)(i.p,{children:["A barnard59 pipeline consists of steps, where each step returns a ",(0,a.jsx)(i.a,{href:"https://nodejs.org/api/stream.html",children:"Stream"}),".\nThe streams of all steps are combined via ",(0,a.jsx)(i.a,{href:"https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options",children:(0,a.jsx)(i.code,{children:".pipe"})}),".\nThe pipeline itself is also a stream."]}),"\n",(0,a.jsx)(i.p,{children:"Depending on the stream types of the first and last stream, the pipeline can be writable or readable.\nIf the pipeline is self-contained, a dummy readable interface is provided to handle events for end of processing and errors."}),"\n",(0,a.jsx)(i.h3,{id:"internals",children:"Internals"}),"\n",(0,a.jsxs)(i.p,{children:["The code to process pipelines makes heavy usage of ",(0,a.jsx)(i.a,{href:"https://github.com/zazuko/rdf-native-loader",children:"RDF Loaders"})," to create JavaScript objects and functions based on a RDF description.\nFor the steps, the ",(0,a.jsx)(i.a,{href:"https://code.described.at/",children:"Code Ontology"})," is used to point or define the code for each step.\nThe ",(0,a.jsx)(i.a,{href:"https://github.com/zazuko/rdf-native-loader-code",children:"RDF Code Loader"})," takes care of importing code referenced as IRIs or directly process literals as JavaScript code."]}),"\n",(0,a.jsx)(i.h2,{id:"pipeline-definition",children:"Pipeline Definition"}),"\n",(0,a.jsx)(i.p,{children:"The following prefixes are used in the code segments of this section:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:"@prefix code: <https://code.described.at/> .\n@prefix p: <https://pipeline.described.at/> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n"})}),"\n",(0,a.jsx)(i.h3,{id:"pipeline-1",children:"Pipeline"}),"\n",(0,a.jsxs)(i.p,{children:["The pipeline itself must have a ",(0,a.jsx)(i.code,{children:"rdf:type"})," of ",(0,a.jsx)(i.code,{children:"p:Pipeline"}),".\nBased on the interfaces of the first and the last step, the pipeline itself is a ",(0,a.jsx)(i.a,{href:"https://nodejs.org/api/stream.html#stream_writable_streams",children:"Writable"})," and/or ",(0,a.jsx)(i.a,{href:"https://nodejs.org/api/stream.html#stream_readable_streams",children:"Readable"})," stream.\nAdditional to the ",(0,a.jsx)(i.code,{children:"p:Pipeline"})," ",(0,a.jsx)(i.code,{children:"rdf:type"}),", ",(0,a.jsx)(i.code,{children:"p:Writable"})," and/or ",(0,a.jsx)(i.code,{children:"p:Readable"})," must be defined accordingly.\nThat can look like this:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:"<#pipeline> a p:Pipeline, p:Writable, p:Readable .\n"})}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Note:"})," The type of the streams could be also detected during runtime or based on metadata for the streams, but that would required deeper understanding of the pipeline and steps structures.\nTo simplify handling of pipeline definitions without runtime data, the stream types are attached to the pipeline definition and errors are thrown in the runtime if they don't match."]}),"\n",(0,a.jsx)(i.h3,{id:"step",children:"Step"}),"\n",(0,a.jsxs)(i.p,{children:["A pipeline consists of one or more steps, which are actually factories which return streams.\nEach step is linked with the previous one via ",(0,a.jsx)(i.a,{href:"https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options",children:(0,a.jsx)(i.code,{children:".pipe"})}),".\nAs this requires to process the steps in order, the steps must be provided as an RDF List.\nThis example shows a very simple pipeline which consists of two steps:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:"<#pipeline> a p:Pipeline ;\n  p:steps [\n    p:stepList ( <#readFile> <#writeFile> )\n  ] .\n"})}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Note:"})," With the two levels (",(0,a.jsx)(i.code,{children:"p:steps"})," and ",(0,a.jsx)(i.code,{children:"p:stepList"}),") it's possible to use a known identifier (Blank Node with name or Named Node) for a step list and reference to it in multiple pipelines.\nThis is useful if pipelines share the same steps, but have different variables."]}),"\n",(0,a.jsxs)(i.p,{children:["The step itself must have a ",(0,a.jsx)(i.code,{children:"rdf:type"})," of ",(0,a.jsx)(i.code,{children:"p:Step"}),".\nThe Code Ontology is used to point to the actual code.\nThis is done with the ",(0,a.jsx)(i.code,{children:"code:implementedBy"})," property and code description with the ",(0,a.jsx)(i.code,{children:"rdf:type"})," of ",(0,a.jsx)(i.code,{children:"code:EcmaScriptModule"}),".\nThe ",(0,a.jsx)(i.code,{children:"code:link"})," points to the JavaScript code file.\n",(0,a.jsx)(i.code,{children:"node:"})," IRIs can be used to use the Node.js resolve logic of ",(0,a.jsx)(i.code,{children:"require"})," to find files and packages.\n",(0,a.jsx)(i.code,{children:"file:"})," IRIs will be expanded to full paths.\nThis example uses the Node.js file system function to create a readable stream.\n",(0,a.jsx)(i.code,{children:"input.txt"})," is used as the only parameter."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:'<#readFile> a p:Step ;\n  code:implementedBy [ a code:EcmaScriptModule ;\n    code:link <node:fs#createReadStream>\n  ] ;\n  code:arguments ( "input.txt" ) .\n'})}),"\n",(0,a.jsx)(i.p,{children:"It's also possible to give the arguments as key value pairs like this:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:'<#parseCsvw> a p:Step ;\n  code:implementedBy [ a code:EcmaScriptModule ;\n    code:link <file:customStreamCode.js>\n  ] ;\n  code:arguments [\n    p:name "url";\n    p:value "http://example.org/"\n  ], [\n    p:name "method";\n    p:value "POST"\n  ] .\n'})}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.code,{children:"customStreamCode.js"})," should export a function which returns a stream.\nDuring the initialization of the pipeline the function is called with the arguments built based on ",(0,a.jsx)(i.code,{children:"code:arguments"}),".\nThe built argument for this example would look like this:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-js",children:"{\n  url: 'http://example.org/',\n  method: 'POST'\n}\n"})}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"Note:"})," Step definitions using common operations may take advantage of ",(0,a.jsx)(i.a,{href:"./simplified-syntax",children:"simplified syntax"}),"."]}),"\n",(0,a.jsx)(i.h3,{id:"variables",children:"Variables"}),"\n",(0,a.jsx)(i.p,{children:"Pipelines can have variables directly attached to the pipeline or injected from the runtime, like the cli tool.\nThe variables can be evaluated via a special RDF Datatype or in ES6 Literals."}),"\n",(0,a.jsx)(i.h4,{id:"definition-attached-to-the-pipeline",children:"Definition attached to the Pipeline"}),"\n",(0,a.jsx)(i.p,{children:"Variables attached to the pipeline are useful when steps, step lists or sub pipelines are reused.\nThe definition looks like this:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:'<#pipeline> a p:Pipeline ;\n  p:variables [\n    p:variable [ a p:Variable ;\n      p:name "filename" ;\n      p:value "example.txt"\n    ]\n  ] .\n'})}),"\n",(0,a.jsx)(i.h4,{id:"using-variables-via-datatype",children:"Using Variables via Datatype"}),"\n",(0,a.jsxs)(i.p,{children:["The values of the variable can be use via a literal with a ",(0,a.jsx)(i.code,{children:"p:VariableName"})," datatype.\nIn the example below, the argument will be replaced with the value of the variable ",(0,a.jsx)(i.code,{children:"filename"}),":"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:'<#readFile> a p:Step;\n  code:implementedBy [ a code:EcmaScriptModule ;\n    code:link <node:fs#createReadStream>\n  ] ;\n  code:arguments ("filename"^^p:VariableName) .\n'})}),"\n",(0,a.jsx)(i.h4,{id:"using-variables-in-template-literals",children:"Using Variables in Template Literals"}),"\n",(0,a.jsx)(i.p,{children:"Variables can be also used in Template Literals.\nThe variable values are injected with their corresponding name, like shown in the following example:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:'<#readFile> a p:Step ;\n  code:implementedBy [ a code:EcmaScriptModule ;\n    code:link <node:fs#createReadStream>\n  ] ;\n  code:arguments ( "${basePath}/input.txt"^^code:EcmaScriptTemplateLiteral ) .\n'})}),"\n",(0,a.jsx)(i.h4,{id:"using-variables-in-ecmascript-code",children:"Using Variables in ECMAScript Code"}),"\n",(0,a.jsxs)(i.p,{children:["Variables are also injected into the context provided to ECMAScript code.\nThe context can be accessed in the standard JavaScript way using ",(0,a.jsx)(i.code,{children:"this"}),".\nThe variables are attached in a ",(0,a.jsx)(i.code,{children:"Set"})," as ",(0,a.jsx)(i.code,{children:"this.variables"}),".\nIn the following example you can see how the variable ",(0,a.jsx)(i.code,{children:"prefix"})," can be accessed in the JavaScript code:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:'<#map> a p:Step ;\n  code:implementedBy [ a code:EcmaScriptModule ;\n    code:link <node:barnard59-base#map>\n  ] ;\n  code:arguments ("""row => {\n    return this.variables.get(\'prefix\') + row\n  }"""^^code:EcmaScript) .\n'})}),"\n",(0,a.jsx)(i.h3,{id:"javascript-arguments",children:"JavaScript Arguments"}),"\n",(0,a.jsxs)(i.p,{children:["Part of the pipeline concept are JavaScript code arguments where describing a logic in a declarative way would be very complex, but is easy to code in one or few lines of JavaScript code.\nAlso for this usage the Code Ontology is used.\nThe ",(0,a.jsx)(i.a,{href:"https://github.com/zazuko/rdf-native-loader-code",children:"RDF Code Loader package"})," provides this functionality.\nSee the docs of the package for more details."]}),"\n",(0,a.jsx)(i.h4,{id:"ecmascript",children:"EcmaScript"}),"\n",(0,a.jsxs)(i.p,{children:["Here is a small example for a step which is using the ",(0,a.jsx)(i.code,{children:"barnard59-base#map"})," operation:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:'<#map> a p:Step ;\n  code:implementedBy [ a code:EcmaScriptModule ;\n    code:link <node:barnard59-base#map>\n  ] ;\n  code:arguments ("""row => {\n    // replace all \xf6 umlauts with oe\n    return row.split(\'\xf6\').join(\'oe\')\n  }"""^^code:EcmaScript) .\n'})}),"\n",(0,a.jsx)(i.h4,{id:"ecmascript-template-literal",children:"EcmaScript Template Literal"}),"\n",(0,a.jsx)(i.p,{children:"Also Template Literals are supported.\nThe defined variables can be used directly.\nA typical use case are file name patterns, derivative from a variable value, like in the following example:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-turtle",children:'<#readFile> a p:Step ;\n  code:implementedBy [ a code:EcmaScriptModule ;\n    code:link <node:fs#createReadStream>\n  ] ;\n  code:arguments ( "${basePath}/input.txt"^^code:EcmaScriptTemplateLiteral ) .\n'})}),"\n",(0,a.jsx)(i.h2,{id:"writing-valid-pipeline",children:"Writing valid pipeline"}),"\n",(0,a.jsx)(i.p,{children:"Writing a valid pipeline can be tedious task. Pipelines are a chain of streams, and those streams have to match."}),"\n",(0,a.jsxs)(i.p,{children:["To learn more about correctly matching those streams, go ",(0,a.jsx)(i.a,{href:"/docs/workflows/explanations/pipeline-validity",children:"here"}),"."]}),"\n",(0,a.jsxs)(i.p,{children:["To automatically detect stream-matching errors, use ",(0,a.jsx)(i.a,{href:"https://github.com/zazuko/barnard59-pipeline-validation",children:"pipeline validator"}),"."]})]})}function p(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},1151:(e,i,n)=>{n.d(i,{Z:()=>l,a:()=>r});var a=n(7294);const t={},s=a.createContext(t);function r(e){const i=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),a.createElement(s.Provider,{value:i},e.children)}}}]);