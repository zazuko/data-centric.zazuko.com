"use strict";(self.webpackChunkdata_centric_zazuko_com=self.webpackChunkdata_centric_zazuko_com||[]).push([[42],{5540:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>h});var s=t(5893),a=t(1151);const o={title:"Implement steps",sidebar_position:1},r="Implementing steps",i={id:"workflows/how-to/implement-steps",title:"Implement steps",description:"As explained on the Pipeline Concepts page, steps are linked from a pipeline using",source:"@site/docs/workflows/how-to/implement-steps.md",sourceDirName:"workflows/how-to",slug:"/workflows/how-to/implement-steps",permalink:"/docs/workflows/how-to/implement-steps",draft:!1,unlisted:!1,editUrl:"https://github.com/zazuko/data-centric.zazuko.com/tree/main/docs/workflows/how-to/implement-steps.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Implement steps",sidebar_position:1},sidebar:"workflowsSidebar",previous:{title:"Getting started",permalink:"/docs/workflows/tutorial/first-pipeline"},next:{title:"Automate pipelines",permalink:"/docs/workflows/how-to/automate-pipeline"}},l={},h=[{value:"Async generators",id:"async-generators",level:2},{value:"through2",id:"through2",level:2},{value:"NodeJS streams",id:"nodejs-streams",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"implementing-steps",children:"Implementing steps"}),"\n",(0,s.jsxs)(n.p,{children:["As explained on the ",(0,s.jsx)(n.a,{href:"/docs/workflows/explanations/pipeline#step",children:"Pipeline Concepts"})," page, steps are linked from a pipeline using\n",(0,s.jsx)(n.code,{children:"code:link"})," property. Out of the box barnard59 supports JavaScript steps. The implementation of a step is a factory\nfunction which returns a stream or an async generator."]}),"\n",(0,s.jsx)(n.p,{children:"This page presents three common ways to implement JavaScript steps."}),"\n",(0,s.jsx)(n.h2,{id:"async-generators",children:"Async generators"}),"\n",(0,s.jsx)(n.p,{children:"The recommended way to implement a step is to use an async generator. Simply return an async generator from the factory.\nIt must have a single argument which is the stream itself as an iterable. The generator can then yield values to the stream."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import nanoid from 'nanoid'\n\n/**\n * @this {import('barnard59-core').Context}\n */\nexport default function step() {\n  // 1. prepare the step\n  const { env } = this\n  const id = nanoid()\n  const ex = env.namespace('http://example.org/')\n  \n  return async function* (stream) {\n    // 2. before first chunk\n    let total = 0\n    yield env.quad(env.blankNode(id), env.ns.rdf.type, ex.StepSummary)\n    \n    for await (const quad of stream) {\n      // 3. push chunks down the pipeline\n      total++\n      yield quad;\n    }\n    \n    // 4. after last chunk\n    yield env.quad(rdf.blankNode(id), ex.totalQuads, total)\n  }.bind(this)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Commented are the four phases of a step:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The first phase is the preparation of the step. This happens before the pipeline\nstarts processing data. Can be ",(0,s.jsx)(n.code,{children:"async"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"The second phase is right before the first chunk is processed."}),"\n",(0,s.jsxs)(n.li,{children:["The third phase is the processing of the stream. Implementors ",(0,s.jsx)(n.code,{children:"yield"})," values to the stream. Individual chunks can be transformed, or skipped by continuing the loop without yielding."]}),"\n",(0,s.jsx)(n.li,{children:"The fourth phase is after the last chunk has been processed. This is the place to clean up resources or push additional data."}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["The operations implemented using async generators always create ",(0,s.jsx)(n.a,{href:"https://nodejs.org/api/stream.html#stream_class_stream_duplex",children:"Duplex streams"}),", which means that they will be used as both readable and writable streams. As a consequence,\nthey will not be able to be used as the first step in a pipeline, as the first step must be a readable stream."]})}),"\n",(0,s.jsx)(n.h2,{id:"through2",children:"through2"}),"\n",(0,s.jsxs)(n.p,{children:["If, for some reason, you cannot use async generators, you can use the ",(0,s.jsx)(n.a,{href:"https://npm.im/through2",children:"through2"})," module as an\neasy alternative to using the NodeJS streams API directly."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import through2 from 'through2'\nimport nanoid from 'nanoid'\n\n/**\n * @this {import('barnard59-core').Context}\n */\nexport default function step() {\n  const { env } = this\n  \n  // 1. prepare the step\n  const id = nanoid()\n  const ex = env.namespace('http://example.org/')\n  let total = 0\n  \n  return through2.obj(function (chunk, encoding, callback) {\n    // 3. push chunks down the pipeline\n    total++\n    this.push(chunk)\n    callback()\n  }, function (callback) {\n    // 4. after last chunk\n    this.push(env.quad(env.blankNode(id), env.ns.rdf.type, ex.StepSummary))\n    this.push(env.quad(env.blankNode(id), ex.totalQuads, total))\n    callback()\n  })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that there are some important differences between the through2 step and async generators:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["When using through2, it is not possible to capture a specific ",(0,s.jsx)(n.code,{children:"before"})," stage. Any additional data must be pushed at the end, in the ",(0,s.jsx)(n.code,{children:"flush"})," callback.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Alternatively, a library like ",(0,s.jsx)(n.a,{href:"https://npm.im/onetime",children:"onetime"})," can be used to create a ",(0,s.jsx)(n.code,{children:"before"})," stage which is only executed once."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"The stream transform and flush functions are not bound to the context. This means that the context must be captured in a closure, or they must be implemented as arrow functions."}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"Similarly, a through2 step will always create a Duplex stream, and cannot be used as the first step in a pipeline."})}),"\n",(0,s.jsx)(n.h2,{id:"nodejs-streams",children:"NodeJS streams"}),"\n",(0,s.jsx)(n.p,{children:"If you need more control over the stream, you can implement the step using the NodeJS streams API directly. This is the\nmost verbose and powerful way."}),"\n",(0,s.jsx)(n.p,{children:"Below is the above example of a step that uses the NodeJS streams API directly. Same principles as with through2 apply here."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { Transform } from 'stream'\nimport nanoid from 'nanoid'\n\n/**\n * @this {import('barnard59-core').Context}\n */\nexport default function step() {\n  const { env } = this\n  \n  // 1. prepare the step\n  const id = nanoid()\n  const ex = env.namespace('http://example.org/')\n  let total = 0\n  \n  return new Transform({\n    objectMode: true,\n    transform (chunk, encoding, callback) {\n      // 3. push chunks down the pipeline\n      total++\n      this.push(chunk)\n      callback()\n    },\n    flush (callback) {\n      // 4. after last chunk\n      this.push(env.quad(env.blankNode(id), env.ns.rdf.type, ex.StepSummary))\n      this.push(env.quad(env.blankNode(id), ex.totalQuads, total))\n      callback()\n    }\n  })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The major difference between this and methods above is the possibility to implement streams which are only ",(0,s.jsx)(n.code,{children:"Readable"})," or\nonly ",(0,s.jsx)(n.code,{children:"Writable"}),". This means that this method can be used to implement the first and last step in a pipeline."]}),"\n",(0,s.jsx)(n.p,{children:"For example, the following step will create a stream which emits a single quad and then ends."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { Readable } from 'stream'\n\n/**\n * @this {import('barnard59-core').Context}\n */\nexport default function step() {\n  const { env } = this\n  \n  return new Readable({\n    objectMode: true,\n    read () {\n      this.push(env.quad(env.blankNode(), env.ns.rdf.type, env.ns.rdfs.Resource))\n      this.push(null)\n    }\n  })\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>r});var s=t(7294);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);